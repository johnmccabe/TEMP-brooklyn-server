package brooklyn.entity.basic.lifecycle.legacy

import java.util.Map

import org.slf4j.Logger
import org.slf4j.LoggerFactory

import brooklyn.entity.basic.Attributes
import brooklyn.entity.basic.EntityLocal
import brooklyn.entity.basic.legacy.JavaApp;
import brooklyn.location.basic.SshMachineLocation
import brooklyn.util.internal.LanguageUtils
import brooklyn.util.internal.StringEscapeUtils;

/**
 * Java application installation, configuration and startup using ssh.
 *
 * This class should be extended for use by entities that are implemented by a Java
 * application.
 *
 * TODO complete documentation
 */
public abstract class SshBasedJavaAppSetup extends SshBasedAppSetup {
    static final Logger log = LoggerFactory.getLogger(SshBasedJavaAppSetup.class)

    protected int jmxPort
    protected int rmiPort
    protected Map<String,Map<String,String>> environmentPropertyFiles = [:]
    protected Map<String,Map<String,String>> namedPropertyFiles = [:]

    public SshBasedJavaAppSetup(EntityLocal entity, SshMachineLocation machine) {
        super(entity, machine)
    }

	public boolean isJmxEnabled() { true }
	
    public void setJmxPort(int val) {
        jmxPort = val
    }

    public void setRmiPort(int val) {
        rmiPort = val
    }

    public void setEnvironmentPropertyFiles(Map<String,Map<String,String>> propertyFiles) {
        this.environmentPropertyFiles << propertyFiles
    }

    public void setNamedPropertyFiles(Map<String,Map<String,String>> propertyFiles) {
        this.namedPropertyFiles << propertyFiles
    }

    @Override
    protected void setEntityAttributes() {
        super.setEntityAttributes()
        entity.setAttribute(Attributes.JMX_PORT, jmxPort)
        entity.setAttribute(Attributes.RMI_PORT, rmiPort)
        entity.setAttribute(Attributes.JMX_USER)
        entity.setAttribute(Attributes.JMX_PASSWORD)
        entity.setAttribute(Attributes.JMX_CONTEXT)
    }

    @Override
    public void config() {
        super.config()
        generateAndCopyPropertyFiles(environmentPropertyFiles)
    }

    private Map<String,String> generateAndCopyPropertyFiles(Map<String,Map<String,String>> propertyFiles) {
        Map<String,String> result = [:]
        
        // FIXME Store securely; may contain credentials!
        for (Map.Entry<String,Map<String,String>> entry in propertyFiles) {
            String name = entry.key
            Map<String,String> contents = entry.value

            Properties props = new Properties()
            for (Map.Entry<String,String> prop in contents) {
                props.setProperty(prop.key, prop.value)
            }
            
            File local = File.createTempFile(entity.id, ".properties")
            String file = LanguageUtils.newUid() + ".properties"
            local.deleteOnExit() // just in case
            FileOutputStream fos = new FileOutputStream(local)
            try {
                props.store(fos, "Auto-generated by Brooklyn; " + file)
                fos.flush()
                String remote = "${runDir}/${file}"
                machine.copyTo local, remote
                
                result.put(name, remote)
            } finally {
                fos.close()
                local.delete()
            }
        }
        
        return result
    }
    
	/** 
	* Sets all JVM options (-X.. -D..) in an environment var JAVA_OPTS.
	* <p>
	* All env vars are wrapped in double quotes when defined in the shell, so values in the resulting map can contain spaces,
	* and must be valid bash expressions.
	* <p>
	* However variables such as JAVA_OPTS used by many scripts get passed as a string, not an array,
	* so spaces in a single argument in the variable, say, a java system define, cannot be passed via this mechanism.
	* We have tried a number of ways around this and conclusion is that the delegated scripts would have to be
	* changed to allow this (treating JAVA_OPTS as an array, eg). If spaces are needed, raise a jira.
	*/
	@Override
	public Map<String, String> getShellEnvironment() {
		super.getShellEnvironment() +
		[ "JAVA_OPTS" : getJavaOpts().collect({
				if (!StringEscapeUtils.isValidForDoubleQuotingInBash(it))
					throw new IllegalArgumentException("will not accept ${it} as valid BASH string (has unescaped double quote)")
				/*"\""+*/ it /*+"\""*/
			}).join(" ") ]
	}

	/** arguments to pass to the JVM; this is the config options
	 * (e.g. -Xmx1024; only the contents of {@link #getCustomJavaConfigOptions()} by default) 
	 * and java system properties (-Dk=v; add custom properties in {@link #getCustomJavaSystemProperties()})
     * <p>
     * See {@link #getShellEnvironment()} for discussion of quoting/escaping strategy.
	 **/
	public List<String> getJavaOpts() {
		getCustomJavaConfigOptions() + (getJavaSystemProperties().collect { k,v -> "-D"+k+(v!=null?"="+v:"") })
	}
	
    /**
     * Returns the complete set of Java system properties (-D defines) to set for the application.
     * <p>
     * This is exposed to the JVM as the contents of the {@code JAVA_OPTS} environment variable. 
     * Default set contains config key, custom system properties, and JMX defines.
     * <p>
	 * Null value means to set -Dkey otherwise it is -Dkey=value.
     * <p>
     * See {@link #getShellEnvironment()} for discussion of quoting/escaping strategy.
     */
    protected Map getJavaSystemProperties() {
        entity.getConfig(JavaApp.JAVA_OPTIONS) + getCustomJavaSystemProperties() + (jmxEnabled ? getJmxJavaSystemProperties() : [:])
    }

    /**
     * Return extra Java system properties (-D defines) used by the application.
     * 
     * Override as needed; default is an empty map.
     */
    protected Map getCustomJavaSystemProperties() { return [:] }

    /**
     * Return extra Java config options, ie arguments starting with - which are
     * passed to the JVM prior to the class name.
     * <p>
     * Note defines are handled separately, in {@link #getCustomJavaSystemProperties()}.
     * <p>
     * Override as needed; default is an empty list.
     */
	protected List<String> getCustomJavaConfigOptions() { return [] }
	
    /**
     * Return the configuration properties required to enable JMX for a Java application.
     *
     * These should be set as properties in the {@code JAVA_OPTS} environment variable
     * when calling the run script for the application.
     *
     * TODO security!
     */
    protected Map getJmxJavaSystemProperties() {
        [
          "com.sun.management.jmxremote" : null,
          "com.sun.management.jmxremote.port" : jmxPort,
          "com.sun.management.jmxremote.ssl" : false,
          "com.sun.management.jmxremote.authenticate" : false,
          "java.rmi.server.hostname" : machine.address.hostName,
        ]
    }
}
