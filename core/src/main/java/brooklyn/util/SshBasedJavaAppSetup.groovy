package brooklyn.util

import java.util.Map

import org.slf4j.Logger
import org.slf4j.LoggerFactory

import brooklyn.entity.basic.Attributes
import brooklyn.entity.basic.EntityLocal
import brooklyn.location.basic.SshMachineLocation
import brooklyn.util.internal.LanguageUtils

/**
 * Java application installation, configuration and startup using ssh.
 *
 * This class should be extended for use by entities that are implemented by a Java
 * application.
 *
 * TODO complete documentation
 */
public abstract class SshBasedJavaAppSetup extends SshBasedAppSetup {
    static final Logger log = LoggerFactory.getLogger(SshBasedJavaAppSetup.class)

    public static final int DEFAULT_FIRST_JMX_PORT = 32199

    protected boolean jmxEnabled = true
    protected int jmxPort
    protected Map<String,Map<String,String>> propFilesToGenerate = [:]
    protected Map<String,String> envVariablesToSet = [:]

    protected String deployDir

    public SshBasedJavaAppSetup(EntityLocal entity, SshMachineLocation machine) {
        super(entity, machine)
    }

    public void setJmxEnabled(boolean val) {
        jmxEnabled = val
    }

    public void setJmxPort(int val) {
        jmxPort = val
    }

    public void setPropertyFiles(Map<String,Map<String,String>> propFilesToGenerate) {
        this.propFilesToGenerate = propFilesToGenerate
    }

    @Override
    protected void setEntityAttributes() {
        super.setEntityAttributes()
        entity.setAttribute(Attributes.JMX_PORT, jmxPort)
    }

    @Override
    public void config() {
        super.config()
        envVariablesToSet = generateAndCopyPropertyFiles()
    }

    private Map<String,String> generateAndCopyPropertyFiles() {
        Map<String,String> result = [:]
        
        // FIXME Store securely; may contain credentials!
        for (Map.Entry<String,Map<String,String>> entry in propFilesToGenerate) {
            String environmentVariableName = entry.key
            Map<String,String> propFileContents = entry.value

            Properties props = new Properties()
            for (Map.Entry<String,String> prop in propFileContents) {
                props.setProperty(prop.key, prop.value)
            }
            
            File tempFileOnDisk = File.createTempFile(entity.id, ".properties");
            FileOutputStream fos = new FileOutputStream(tempFileOnDisk)
            try {
                props.store(fos, "Auto-generated by Brooklyn; referenced by environment variable "+environmentVariableName)
                fos.flush()
                String uniqueFilePath = "${runDir}/"+LanguageUtils.newUid()+".properties"
                machine.copyTo tempFileOnDisk, uniqueFilePath
                
                result.put(environmentVariableName, uniqueFilePath)
            } finally {
                fos.close()
                tempFileOnDisk.delete()
            }
        }
        
        return result
    }
    
    /**
     * Convenience method to generate Java environment options string.
     *
     * Converts the properties {@link Map} entries with a value to {@code -Dkey=value}
     * and entries where the value is null to {@code -Dkey}.
     */
    public static String toJavaDefinesString(Map properties) {
        StringBuffer options = []
        properties.each { key, value ->
	            options.append("-D").append(key)
	            if (value != null && value != "") {
                    // Quote the value if it's a string containing a space.
                    if (value instanceof String && value.indexOf(" ") >= 0)
                        options.append("=\'").append(value).append("\'")
                    else
                        options.append("=").append(value)
                }
	            options.append(" ")
	        }
        return options.toString().trim()
    }

    @Override
    public Map<String, String> getRunEnvironment() {
        return envVariablesToSet
    }

    /**
     * Returns the complete set of Java configuration options required by
     * the application.
     *
     * These should be formatted and passed to the JVM as the contents of
     * the {@code JAVA_OPTS} environment variable. The default set contains
     * only the options required to enable JMX. To add application specific
     * options, override the {@link #getJavaConfigOptions()} method.
     *
     * @see #toJavaDefinesString(Map)
     */
    protected Map getJvmStartupProperties() {
        getJavaConfigOptions() + (jmxEnabled ? getJmxConfigOptions() : [:])
    }

    /**
     * Return extra Java configuration options required by the application.
     * 
     * This should be overridden; default is an empty {@link Map}.
     */
    protected Map getJavaConfigOptions() { return [:] }

    /**
     * Return the configuration properties required to enable JMX for a Java application.
     *
     * These should be set as properties in the {@code JAVA_OPTS} environment variable
     * when calling the run script for the application.
     *
     * TODO security!
     */
    protected Map getJmxConfigOptions() {
        [
          "com.sun.management.jmxremote" : "",
          "com.sun.management.jmxremote.port" : jmxPort,
          "com.sun.management.jmxremote.ssl" : false,
          "com.sun.management.jmxremote.authenticate" : false,
          "java.rmi.server.hostname" : machine.address.hostName,
        ]
    }

    public void setDeployDir(String val) {
        deployDir = val
    }

    /**
     * Copy a file to the {@link #runDir} on the server.
     *
     * @return The location of the file on the server
     */
    public String copy(File file) {
        String target = runDir + "/" + file.name
        log.info "Deploying file {} to {} on {}", file.name, target, machine
        try {
            machine.copyTo file, target
        } catch (IOException ioe) {
            log.error "Failed to copy {} to {}: {}", file.name, machine, ioe.message
            throw new IllegalStateException("Failed to copy ${file.name} to ${machine}", ioe)
        }
        return target
    }

    /**
     * Copies a file to the server and invokes {@link #getDeployScript(String)}
     * for further processing.
     */
    public void deploy(File file) {
        String target = copy(file)
        List<String> deployScript = getDeployScript(target)
        if (deployScript && !deployScript.isEmpty()) {
            int result = machine.run(out:System.out, deployScript)
            if (result != 0) {
                log.error "Failed to deploy {} on {}, result {}", file.name, machine, result
	            throw new IllegalStateException("Failed to deploy ${file.name} on ${machine}")
            } else {
                log.debug "Deployed {} on {}", file.name, machine
            }
        }
    }

    /**
     * Deploy the file found at the specified location on the server.
     *
     * Checks that the file exists, and fails if not accessible, otherwise copies it
     * to the configured deploy directory. This is required because exit status from
     * the Jsch scp command is not reliable.
     */
    public List<String> getDeployScript(String locOnServer) {
        List<String> script = [
            "test -f ${locOnServer} || exit 1",
            "cp ${locOnServer} ${deployDir}",
        ]
        return script
    }
}
