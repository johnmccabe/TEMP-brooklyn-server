package brooklyn.util.task

import groovy.time.TimeDuration

import java.util.concurrent.Callable
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ScheduledFuture
import java.util.concurrent.TimeUnit

import brooklyn.management.Task
import brooklyn.util.internal.TimeExtras

class ScheduledTask extends BasicTask {

	final Callable<Task> taskFactory;
	/** initial delay before running, set as flag in constructor; defaults to 0 */
	private TimeDuration delay;
	/** time to wait between executions, or null if not to repeat (default), set as flag to constructor;
	 * this may be modified for subsequent submissions by a running task generated by the factory 
	 * using getSubmittedByTask().setPeriod(TimeDuration) */
	TimeDuration period = null;
	/** optional, set as flag in constructor; defaults to null meaning no limit */
	Integer maxIterations = null;
	
	private int runCount=0;
	private Task recentRun, nextRun;

	public int getRunCount() { runCount }
	public ScheduledFuture getNextScheduled() { result }
	
	static { TimeExtras.init() }
	
	public ScheduledTask(Map flags=[:], Callable<Task> taskFactory) {
		super(flags);
		this.taskFactory = taskFactory
		
		delay = flags.remove("delay") ?: 0*TimeUnit.SECONDS;
		period = flags.remove("period") ?: null;
		maxIterations = flags.remove("maxIterations") ?: null;
	}
	
	public Task newTask() { taskFactory.call() }
	
	protected String getActiveTaskStatusString(int verbosity) {
		String rv = "Scheduler";
		if (runCount>0) rv += ", iteration "+(runCount+1);
		if (recentRun!=null) rv += ", last run "+(System.currentTimeMillis()-recentRun.startTimeUtc)+" ms ago";
		if (getNextScheduled()) {
			long untilNext = getNextScheduled().getDelay(TimeUnit.MILLISECONDS);
			if (untilNext>0)
				rv += ", next in "+untilNext+" ms"
			else 
				rv += ", next imminent"
		}
	}
	
	@Override
	public boolean isDone() {
		cancelled || (maxIterations!=null && maxIterations <= runCount) || (period==null && nextRun.isDone())
	}
	
	public void blockUntilEnded() {
		while (!isDone()) super.blockUntilEnded();
	}

	/** gets the value of the most recently run task */
	public Object get() throws InterruptedException, ExecutionException {
		blockUntilStarted()
		if (recentRun) recentRun.get()
		else result.get().get()
	}
}
