package brooklyn.util.task;

import static brooklyn.util.GroovyJavaMethods.elvis;
import static brooklyn.util.GroovyJavaMethods.truth;
import groovy.time.TimeDuration;

import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

import brooklyn.management.Task;
import brooklyn.util.JavaGroovyEquivalents;
import brooklyn.util.MutableMap;

import com.google.common.base.Throwables;

public class ScheduledTask extends BasicTask {

    // TODO See BasicExecutionManager.submitNewScheduledTask for where these fields are actually set.
    // Would be nice if the scheduledTask was more self-contained, rather than its fields being
    // modified by a different class in a non-obvious way...
    
	final Callable<Task> taskFactory;
	/** initial delay before running, set as flag in constructor; defaults to 0 */
	protected TimeDuration delay;
	/** time to wait between executions, or null if not to repeat (default), set as flag to constructor;
	 * this may be modified for subsequent submissions by a running task generated by the factory 
	 * using getSubmittedByTask().setPeriod(TimeDuration) */
	protected TimeDuration period = null;
	/** optional, set as flag in constructor; defaults to null meaning no limit */
	protected Integer maxIterations = null;
	
	protected int runCount=0;
	protected Task recentRun, nextRun;

	public int getRunCount() { return runCount; }
	public ScheduledFuture getNextScheduled() { return (ScheduledFuture)result; }

    public ScheduledTask(Callable<Task> taskFactory) {
        this(MutableMap.of(), taskFactory);
    }
	public ScheduledTask(Map flags, Callable<Task> taskFactory) {
		super(flags);
		this.taskFactory = taskFactory;
		
		delay = JavaGroovyEquivalents.toTimeDuration(elvis(flags.remove("delay"), 0));
		period = JavaGroovyEquivalents.toTimeDuration(elvis(flags.remove("period"), null));
		maxIterations = elvis(flags.remove("maxIterations"), null);
	}

    public Callable<Task> getTaskFactory() {
        return taskFactory;
    }

	public Task newTask() {
	    try {
	        return taskFactory.call();
	    } catch (Exception e) {
	        throw Throwables.propagate(e);
	    }
    }
	
	protected String getActiveTaskStatusString(int verbosity) {
		StringBuilder rv = new StringBuilder("Scheduler");
		if (runCount>0) rv.append(", iteration "+(runCount+1));
		if (recentRun!=null) rv.append(", last run "+(System.currentTimeMillis()-recentRun.getStartTimeUtc())+" ms ago");
		if (truth(getNextScheduled())) {
			long untilNext = getNextScheduled().getDelay(TimeUnit.MILLISECONDS);
			if (untilNext>0)
			    rv.append(", next in "+untilNext+" ms");
			else 
			    rv.append(", next imminent");
		}
		return rv.toString();
	}
	
	@Override
	public boolean isDone() {
		return isCancelled() || (maxIterations!=null && maxIterations <= runCount) || (period==null && nextRun!=null && nextRun.isDone());
	}
	
	public synchronized void blockUntilFirstScheduleStarted() {
	    // TODO Assumes that maxIterations is not negative!
        while (true) {
            if (isCancelled()) throw new CancellationException();
            if (recentRun==null)
                try {
                    wait();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    Throwables.propagate(e);
                }
            if (recentRun!=null) return;
        }
	}
	
	public void blockUntilEnded() {
		while (!isDone()) super.blockUntilEnded();
	}

	/** gets the value of the most recently run task */
	public Object get() throws InterruptedException, ExecutionException {
		blockUntilStarted();
        blockUntilFirstScheduleStarted();
		return (truth(recentRun)) ? recentRun.get() : result.get();
	}
}
